# script for stm32h7x family

#
# stm32h7 devices support both JTAG and SWD transports.
#
source [find target/swj-dp.tcl]
source [find mem_helper.tcl]

if { [info exists CHIPNAME] } {
	set _CHIPNAME $CHIPNAME
} else {
	set _CHIPNAME stm32h7x
}

if { [info exists DUAL_BANK] } {
	set $_CHIPNAME.DUAL_BANK $DUAL_BANK
	unset DUAL_BANK
} else {
	set $_CHIPNAME.DUAL_BANK 0
}

if { [info exists DUAL_CORE] } {
	set $_CHIPNAME.DUAL_CORE $DUAL_CORE
	unset DUAL_CORE
} else {
	set $_CHIPNAME.DUAL_CORE 0
}

# Issue a warning when hla is used, and fallback to single core configuration
if { [set $_CHIPNAME.DUAL_CORE] && [using_hla] } {
	echo "Warning : hla does not support multicore debugging"
	set $_CHIPNAME.DUAL_CORE 0
}

if { [info exists USE_CTI] } {
	set $_CHIPNAME.USE_CTI $USE_CTI
	unset USE_CTI
} else {
	set $_CHIPNAME.USE_CTI 0
}

# Issue a warning when DUAL_CORE=0 and USE_CTI=1, and fallback to USE_CTI=0
if { ![set $_CHIPNAME.DUAL_CORE] && [set $_CHIPNAME.USE_CTI] } {
	echo "Warning : could not use CTI with a single core device, CTI is disabled"
	set $_CHIPNAME.USE_CTI 0
}

if { [info exists $_CHIPNAME.USE_CTI] } {
	if { [info exists CPU1_CAN_BREAK_CPU0] } {
		set $_CHIPNAME.CTI_CM4_CAN_BREAK_CM7 $CPU1_CAN_BREAK_CPU0
		unset CPU1_CAN_BREAK_CPU0
	} else {
		set $_CHIPNAME.CTI_CM4_CAN_BREAK_CM7 0
	}

	if { [info exists CPU0_CAN_BREAK_CPU1] } {
		set $_CHIPNAME.CTI_CM7_CAN_BREAK_CM4 $CPU0_CAN_BREAK_CPU1
		unset CPU0_CAN_BREAK_CPU1
	} else {
		set $_CHIPNAME.CTI_CM7_CAN_BREAK_CM4 0
	}
}

if { [info exists CORE_RESET] } {
	set _CORE_RESET $CORE_RESET
} else {
	set _CORE_RESET 1
}

if { [info exists CONNECT_UNDER_RESET] } {
	set _CONNECT_UNDER_RESET $CONNECT_UNDER_RESET
} else {
	set _CONNECT_UNDER_RESET 0
}

if { [info exists ENABLE_LOW_POWER] } {
	set _ENABLE_LOW_POWER $ENABLE_LOW_POWER
} else {
	set _ENABLE_LOW_POWER 0
}

if { [info exists STOP_WATCHDOG] } {
	set _STOP_WATCHDOG $STOP_WATCHDOG
} else {
	set _STOP_WATCHDOG 0
}

set _ENDIAN little

# Work-area is a space in RAM used for flash programming
# By default use 64kB
if { [info exists WORKAREASIZE] } {
	set _WORKAREASIZE $WORKAREASIZE
} else {
	set _WORKAREASIZE 0x10000
}

# jtag scan chain
if { [info exists CPUTAPID] } {
	set _CPUTAPID $CPUTAPID
} else {
	if { [using_jtag] } {
		set _CPUTAPID 0x6ba00477
	} else {
		set _CPUTAPID 0x6ba02477
	}
}

swj_newdap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID
dap create $_CHIPNAME.dap -chain-position $_CHIPNAME.cpu

if {![using_hla]} {
	# STM32H7 provides an APB-AP at access port 2, which allows the access to
	# the debug and trace features on the system APB System Debug Bus (APB-D).
	target create $_CHIPNAME.ap2 mem_ap -dap $_CHIPNAME.dap -ap-num 2
}

# Temporary until only one OpenOCD for all debug sessions
#if { [info exists $_CHIPNAME.DUAL_CORE] } {
#	set _CM7 1
#	set _CM4 1
#} else {
#	if { [info exists CM7] } {
#		set _CM7 1
#		unset CM7
#	}
#	if { [info exists CM4] } {
#		set _CM4 1
#		unset CM4
#	}
#}

# Assigned gdb port to be used during target creation
if { [info exists AP_NUM] && [info exists GDB_PORT] } {
	if { [expr ($AP_NUM == 0)] } {
		set _GDB_PORT_CM7 $GDB_PORT
		set _GDB_PORT_CM4 [expr $GDB_PORT + 1]
	} else {
		set _GDB_PORT_CM7 [expr $GDB_PORT + 1]
		set _GDB_PORT_CM4 $GDB_PORT
	}
}

# APNum definition
set _AP_NUM_CM7 0
set _AP_NUM_CM4 3

if { [info exists _GDB_PORT_CM7] } {
	target create $_CHIPNAME.cm7 cortex_m -endian $_ENDIAN -dap $_CHIPNAME.dap -ap-num $_AP_NUM_CM7 -gdb-port $_GDB_PORT_CM7
} else {
	target create $_CHIPNAME.cm7 cortex_m -endian $_ENDIAN -dap $_CHIPNAME.dap -ap-num $_AP_NUM_CM7
}

if { [set $_CHIPNAME.DUAL_CORE] } {
	# create CTI to be able to stop a CTI previously started on board. Even if we do not use CTI.
	cti create $_CHIPNAME.cm7_cti -dap $_CHIPNAME.dap -ap-num $_AP_NUM_CM7 -ctibase 0xE0043000
	# avoid reseting the target in dual core mode
	$_CHIPNAME.cm7 configure -event gdb-flash-erase-start "soft_reset_halt"
	$_CHIPNAME.cm7 configure -event gdb-flash-write-end "soft_reset_halt"
}

$_CHIPNAME.cm7 configure -work-area-phys 0x20000000 -work-area-size $_WORKAREASIZE -work-area-backup 0

flash bank $_CHIPNAME.bank1.cm7 stm32h7x 0x08000000 0 0 0 $_CHIPNAME.cm7

if { [set $_CHIPNAME.DUAL_BANK] } {
	flash bank $_CHIPNAME.bank2.cm7 stm32h7x 0x08100000 0 0 0 $_CHIPNAME.cm7
}

if { [set $_CHIPNAME.DUAL_CORE] } {
	if { [info exists _GDB_PORT_CM4] } {
		target create $_CHIPNAME.cm4 cortex_m -endian $_ENDIAN -dap $_CHIPNAME.dap -ap-num $_AP_NUM_CM4 -gdb-port $_GDB_PORT_CM4
	} else {
		target create $_CHIPNAME.cm4 cortex_m -endian $_ENDIAN -dap $_CHIPNAME.dap -ap-num $_AP_NUM_CM4
	}
	# create CTI to be able to stop a CTI previously started on board. Even if we do not use CTI.
	cti create $_CHIPNAME.cm4_cti -dap $_CHIPNAME.dap -ap-num $_AP_NUM_CM4 -ctibase 0xE0043000

	$_CHIPNAME.cm4 configure -work-area-phys 0x38000000 -work-area-size $_WORKAREASIZE -work-area-backup 0

	# avoid reseting the target in dual core mode
	$_CHIPNAME.cm4 configure -event gdb-flash-erase-start "soft_reset_halt"
	$_CHIPNAME.cm4 configure -event gdb-flash-write-end "soft_reset_halt"

	flash bank $_CHIPNAME.bank1.cm4 stm32h7x 0x08000000 0 0 0 $_CHIPNAME.cm4

	if { [set $_CHIPNAME.DUAL_BANK] } {
		flash bank $_CHIPNAME.bank2.cm4 stm32h7x 0x08100000 0 0 0 $_CHIPNAME.cm4
	}

	if { [expr ($AP_NUM == 0)] } {
		# Make sure that cm7 is selected
		targets $_CHIPNAME.cm7
	}
}

adapter_nsrst_delay 100
if {[using_jtag]} {
	jtag_ntrst_delay 100
}

if { [info exists CLOCK_FREQ] } {
	set _CLOCK_FREQ $CLOCK_FREQ
} else {
	set _CLOCK_FREQ 4000
}
adapter_khz $_CLOCK_FREQ

# The STM32H7 does not support connect_assert_srst mode because the AXI is
# unavailable while SRST is asserted, and that is used to access the DBGMCU
# component at 0x5C001000 in the examine-end event handler.
#
# It is possible to access the DBGMCU component at 0xE00E1000 via AP2 instead
# of the default AP0, and that works with SRST asserted; however, nonzero AP
# usage does not work with HLA, so is not done by default. That change could be
# made in a local configuration file if connect_assert_srst mode is needed for
# a specific application and a non-HLA adapter is in use.

if {![using_hla]} {
	global _CORE_RESET

	if { [expr ($_CORE_RESET == 1)] } {
		# Only resetting Core
		$_CHIPNAME.cm7 cortex_m reset_config vectreset
		if { [set $_CHIPNAME.DUAL_CORE] } {
			$_CHIPNAME.cm4 cortex_m reset_config vectreset
		}
	} else {
		# if srst is not fitted use SYSRESETREQ to perform a soft reset
		$_CHIPNAME.cm7 cortex_m reset_config sysresetreq
		if { [set $_CHIPNAME.DUAL_CORE] } {
			$_CHIPNAME.cm4 cortex_m reset_config sysresetreq
		}
	}

	# Set CSW[27], which according to ARM ADI v5 appendix E1.4 maps to AHB signal
	# HPROT[3], which according to AMBA AHB/ASB/APB specification chapter 3.7.3
	# makes the data access cacheable. This allows reading and writing data in the
	# CPU cache from the debugger, which is far more useful than going straight to
	# RAM when operating on typical variables, and is generally no worse when
	# operating on special memory locations.
	$_CHIPNAME.dap apcsw 0x08000000 0x08000000
}

# like mrw, but with target selection
proc stm32h7x_mrw {used_target reg} {
	set value ""
	$used_target mem2array value 32 $reg 1
	return $value(0)
}

# like mmw, but with target selection
proc stm32h7x_mmw {used_target reg setbits clearbits} {
	set old [stm32h7x_mrw $used_target $reg]
	set new [expr ($old & ~$clearbits) | $setbits]
	$used_target mww $reg $new
}

# mmw for dbgmcu component registers, it accepts the register offset from dbgmcu base
# this procedure will use the mem_ap on AP2 whenever possible
proc stm32h7x_dbgmcu_mmw {reg_offset setbits clearbits} {
	global _CHIPNAME

	# use $_CHIPNAME.ap2 if possible, and use the proper dbgmcu base address
	if {![using_hla]} {
		set used_target $_CHIPNAME.ap2
		set reg_addr [expr 0xE00E1000 + $reg_offset]
	} {
		set used_target [target current]
		set reg_addr [expr 0x5C001000 + $reg_offset]
	}

	stm32h7x_mmw $used_target $reg_addr $setbits $clearbits
}

if { [set $_CHIPNAME.USE_CTI] } {
	proc stm32h7x_cti_prepare_restart {} {
		stm32h7x_cti_prepare_restart_one cm7_cti
		stm32h7x_cti_prepare_restart_one cm4_cti
	}

	proc stm32h7x_cti_prepare_restart_one {cti} {
		global _CHIPNAME

		# Acknowlodge EDBGRQ at TRIGOUT0
		$_CHIPNAME.$cti write INACK 0x01
		$_CHIPNAME.$cti write INACK 0x00
	}

	proc stm32h7x_cti_stop {} {
		stm32h7x_cti_stop_one cm7_cti
		stm32h7x_cti_stop_one cm4_cti
	}

	proc stm32h7x_cti_stop_one {cti} {
		global _CHIPNAME

		stm32h7x_cti_prepare_restart_one $cti
		$_CHIPNAME.$cti write INEN0 0x0
		$_CHIPNAME.$cti write OUTEN0 0x0
		$_CHIPNAME.$cti enable off
	}

	proc stm32h7x_cti_start {} {
		stm32h7x_cti_start_cm7
		stm32h7x_cti_start_cm4
	}

	proc stm32h7x_cti_start_cm7 {} {
		global _CHIPNAME
		global $_CHIPNAME.CTI_CM7_CAN_BREAK_CM4
		global $_CHIPNAME.CTI_CM4_CAN_BREAK_CM7

		if { [set $_CHIPNAME.CTI_CM7_CAN_BREAK_CM4] } {
			# CM7_CTI TRIGIN0 (HALTED) and CM4_CTI TRIGOUT0 (EDBGRQ) at CTM_CHANNEL_0
			$_CHIPNAME.cm7_cti write INEN0 0x1
		} else {
			$_CHIPNAME.cm7_cti write INEN0 0x0
		}

		if { [set $_CHIPNAME.CTI_CM4_CAN_BREAK_CM7] } {
			# CM7_CTI TRIGOUT0 (EDBGRQ) and CM4_CTI TRIGIN0 (HALTED) at CTM_CHANNEL_2
			$_CHIPNAME.cm7_cti write OUTEN0 0x4
		}

		# enable CTIs
		$_CHIPNAME.cm7_cti enable on
	}

	proc stm32h7x_cti_start_cm4 {} {
		global _CHIPNAME
		global $_CHIPNAME.CTI_CM7_CAN_BREAK_CM4
		global $_CHIPNAME.CTI_CM4_CAN_BREAK_CM7

		if { [set $_CHIPNAME.CTI_CM7_CAN_BREAK_CM4] } {
			# CM7_CTI TRIGIN0 (HALTED) and CM4_CTI TRIGOUT0 (EDBGRQ) at CTM_CHANNEL_0
			$_CHIPNAME.cm4_cti write OUTEN0 0x1
		}

		if { [set $_CHIPNAME.CTI_CM4_CAN_BREAK_CM7] } {
			# CM7_CTI TRIGOUT0 (EDBGRQ) and CM4_CTI TRIGIN0 (HALTED) at CTM_CHANNEL_2
			$_CHIPNAME.cm4_cti write INEN0 0x4
		}

		# enable CTIs
		$_CHIPNAME.cm4_cti enable on
	}
}

$_CHIPNAME.cm7 configure -event examine-end {
	global _ENABLE_LOW_POWER
	global _STOP_WATCHDOG
	global _CHIPNAME
	global $_CHIPNAME.USE_CTI

	if {[set $_CHIPNAME.USE_CTI]} {
		# Disable corresponding CTI by default
		stm32h7x_cti_stop_one cm7_cti
	}

	# Enable D3 and D1 DBG clocks
	# DBGMCU_CR |= D3DBGCKEN | D1DBGCKEN
	stm32h7x_dbgmcu_mmw 0x004 0x00600000 0

	if { [expr ($_ENABLE_LOW_POWER == 1)] } {
		# Enable debug during low power modes (uses more power)
		# DBGMCU_CR |= DBG_STANDBY | DBG_STOP | DBG_SLEEP in D3, D2 & D1 Domains
		stm32h7x_dbgmcu_mmw 0x004 0x000001BF 0
	}
	if { [expr ($_ENABLE_LOW_POWER == 0)] } {
		# Disable debug during low power modes
		# DBGMCU_CR |= ~(DBG_STANDBY | DBG_STOP | DBG_SLEEP)
		stm32h7x_dbgmcu_mmw 0x004 0 0x000001BF
	}
	if { [expr ($_STOP_WATCHDOG == 1)] } {
		# Stop watchdog counters during halt
		# DBGMCU_APB3FZ1 |= WWDG1
		stm32h7x_dbgmcu_mmw 0x034 0x00000040 0
		# DBGMCU_APB1LFZ1 |= WWDG2
		stm32h7x_dbgmcu_mmw 0x03C 0x00000800 0
		# DBGMCU_APB4FZ1 |= WDGLSD1 | WDGLSD2
		stm32h7x_dbgmcu_mmw 0x054 0x000C0000 0
	}
	if { [expr ($_STOP_WATCHDOG == 0)] } {
		# Don't Stop watchdog counters during halt
		# DBGMCU_APB3FZ1 |= ~WWDG1
		stm32h7x_dbgmcu_mmw 0x034 0 0x00000040
		# DBGMCU_APB1LFZ1 |= ~WWDG2
		stm32h7x_dbgmcu_mmw 0x03C 0 0x00000800
		# DBGMCU_APB4FZ1 |= ~(WDGLSD1 | WDGLSD2)
		stm32h7x_dbgmcu_mmw 0x054 0 0x000C0000
	}
	if { [expr ($_ENABLE_LOW_POWER == 0)] && [expr ($_STOP_WATCHDOG == 0)] } {
		# Disable D3 and D1 DBG clocks
		# DBGMCU_CR |= ~(DBG_CKEN_D3 | DBG_CKEN_D1)
		stm32h7x_dbgmcu_mmw 0x004 0 0x00600000
	}

	if {[set $_CHIPNAME.USE_CTI]} {
		stm32h7x_cti_start
	}
}

$_CHIPNAME.cm7 configure -event trace-config {
	# Set TRACECLKEN; TRACE_MODE is set to async; when using sync
	# change this value accordingly to configure trace pins
	# assignment
	stm32h7x_dbgmcu_mmw 0x004 0x00100000 0
}

$_CHIPNAME.cm7 configure -event reset-init {
	global _CLOCK_FREQ

	# Clock after reset is HSI at 64 MHz, no need of PLL
	adapter_khz $_CLOCK_FREQ
}

$_CHIPNAME.cm7 configure -event halted { 
	global _CHIPNAME
	global $_CHIPNAME.USE_CTI

	if { [set $_CHIPNAME.USE_CTI] } {
		stm32h7x_cti_prepare_restart
	}
}

$_CHIPNAME.cm7 configure -event gdb-attach {
global _CONNECT_UNDER_RESET

	# Needed to be able to use the connect_assert_srst in reset_config
	if { [expr ($_CONNECT_UNDER_RESET == 1)] } {
		reset init
	}
}

$_CHIPNAME.cm7 configure -event gdb-detach {
	global _CHIPNAME
	global $_CHIPNAME.USE_CTI

	if { [set $_CHIPNAME.USE_CTI] } {
		stm32h7x_cti_prepare_restart
		stm32h7x_cti_stop
	}
	# to close connection if debug mode entered
	if { [info exists AP_NUM] && [expr ($AP_NUM == 0)] } {
		shutdown
	}
}

if { [set $_CHIPNAME.DUAL_CORE] } {
	$_CHIPNAME.cm4 configure -event examine-end {
		global _ENABLE_LOW_POWER
		global _STOP_WATCHDOG
		global _CHIPNAME
		global $_CHIPNAME.USE_CTI

		if { [set $_CHIPNAME.USE_CTI] } {
			# Disable corresponding CTI
			stm32h7x_cti_stop_one cm4_cti
		}

		# Enable D3 and D1 DBG clocks
		# DBGMCU_CR |= D3DBGCKEN | D1DBGCKEN
		stm32h7x_dbgmcu_mmw 0x004 0x00600000 0

		if { [expr ($_ENABLE_LOW_POWER == 1)] } {
			# Enable debug during low power modes (uses more power)
			# DBGMCU_CR |= DBG_STANDBY | DBG_STOP | DBG_SLEEP in D3, D2 & D1 Domains
			stm32h7x_dbgmcu_mmw 0x004 0x000001BF 0
		}
		if { [expr ($_ENABLE_LOW_POWER == 0)] } {
			# Disable debug during low power modes
			# DBGMCU_CR |= ~(DBG_STANDBY | DBG_STOP | DBG_SLEEP)
			stm32h7x_dbgmcu_mmw 0x004 0 0x000001BF
		}
		if { [expr ($_STOP_WATCHDOG == 1)] } {
			# Stop watchdog counters during halt
			# DBGMCU_APB3FZ2 |= WWDG1
			stm32h7x_dbgmcu_mmw 0x038 0x00000040 0
			# DBGMCU_APB1LFZ2 |= WWDG2
			stm32h7x_dbgmcu_mmw 0x040 0x00000800 0
			# DBGMCU_APB4FZ2 |= WDGLSD1 | WDGLSD2
			stm32h7x_dbgmcu_mmw 0x058 0x000C0000 0
		}
		if { [expr ($_STOP_WATCHDOG == 0)] } {
			# Don't Stop watchdog counters during halt
			# DBGMCU_APB3FZ2 |= ~WWDG1
			stm32h7x_dbgmcu_mmw 0x038 0 0x00000040
			# DBGMCU_APB1LFZ2 |= ~WWDG2
			stm32h7x_dbgmcu_mmw 0x040 0 0x00000800
			# DBGMCU_APB4FZ2 |= ~(WDGLSD1 | WDGLSD2)
			stm32h7x_dbgmcu_mmw 0x058 0 0x000C0000
		}
		if { [expr ($_ENABLE_LOW_POWER == 0)] && [expr ($_STOP_WATCHDOG == 0)] } {
			# Disable D3 and D1 DBG clocks
			# DBGMCU_CR |= ~(DBG_CKEN_D3 | DBG_CKEN_D1)
			stm32h7x_dbgmcu_mmw 0x004 0 0x00600000
		}

		if { [set $_CHIPNAME.USE_CTI] } {
			stm32h7x_cti_start
		}
	}

  	$_CHIPNAME.cm4 configure -event trace-config {
		# Set TRACECLKEN; TRACE_MODE is set to async; when using sync
		# change this value accordingly to configure trace pins
		# assignment
		stm32h7x_dbgmcu_mmw 0x004 0x00100000 0
	}

	$_CHIPNAME.cm4 configure -event reset-init {
		global _CLOCK_FREQ

		# Clock after reset is HSI at 64 MHz, no need of PLL
		adapter_khz $_CLOCK_FREQ
	}

	$_CHIPNAME.cm4 configure -event halted {
		global _CHIPNAME
		global $_CHIPNAME.USE_CTI

		if { [set $_CHIPNAME.USE_CTI] } {
			stm32h7x_cti_prepare_restart
		}
	}

	$_CHIPNAME.cm4 configure -event gdb-attach {
		global _CONNECT_UNDER_RESET

		# Needed to be able to use the connect_assert_srst in reset_config
		if { [expr ($_CONNECT_UNDER_RESET == 1)] } {
			reset init
		}
	}

	$_CHIPNAME.cm4 configure -event gdb-detach {
		global _CHIPNAME
		global $_CHIPNAME.USE_CTI

		if { [set $_CHIPNAME.USE_CTI] } {
			stm32h7x_cti_prepare_restart
			stm32h7x_cti_stop
		}
		# to close connection if debug mode entered
		if { [info exists AP_NUM] && [expr ($AP_NUM == 3)] } {
			shutdown
		}
	}
}
